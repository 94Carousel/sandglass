// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: sandglass.proto

/*
	Package sgproto is a generated protocol buffer package.

	It is generated from these files:
		sandglass.proto

	It has these top-level messages:
		Message
		DUIDReply
		CreateTopicParams
		TopicReply
		StoreLocallyReply
		FetchFromRequest
		FetchRangeRequest
		GetRequest
		ConsumeFromGroupRequest
		OffsetChangeRequest
		OffsetChangeReply
		LastOffsetReply
		LastOffsetRequest
		FetchFromSyncRequest
		HasResponse
		SyncRequest
		SyncResponse
*/
package sgproto

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "google.golang.org/genproto/googleapis/api/annotations"
import _ "github.com/gogo/protobuf/gogoproto"

import github_com_celrenheit_sandflake "github.com/celrenheit/sandflake"

import bytes "bytes"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import strings "strings"
import reflect "reflect"
import github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type TopicKind int32

const (
	TopicKind_TimerKind     TopicKind = 0
	TopicKind_CompactedKind TopicKind = 1
)

var TopicKind_name = map[int32]string{
	0: "TimerKind",
	1: "CompactedKind",
}
var TopicKind_value = map[string]int32{
	"TimerKind":     0,
	"CompactedKind": 1,
}

func (x TopicKind) String() string {
	return proto.EnumName(TopicKind_name, int32(x))
}
func (TopicKind) EnumDescriptor() ([]byte, []int) { return fileDescriptorSandglass, []int{0} }

type StorageDriver int32

const (
	StorageDriver_RocksDB StorageDriver = 0
	StorageDriver_Badger  StorageDriver = 1
)

var StorageDriver_name = map[int32]string{
	0: "RocksDB",
	1: "Badger",
}
var StorageDriver_value = map[string]int32{
	"RocksDB": 0,
	"Badger":  1,
}

func (x StorageDriver) String() string {
	return proto.EnumName(StorageDriver_name, int32(x))
}
func (StorageDriver) EnumDescriptor() ([]byte, []int) { return fileDescriptorSandglass, []int{1} }

type ConsistencyLevel int32

const (
	ConsistencyLevel_ONE    ConsistencyLevel = 0
	ConsistencyLevel_QUORUM ConsistencyLevel = 10
	ConsistencyLevel_ALL    ConsistencyLevel = 20
)

var ConsistencyLevel_name = map[int32]string{
	0:  "ONE",
	10: "QUORUM",
	20: "ALL",
}
var ConsistencyLevel_value = map[string]int32{
	"ONE":    0,
	"QUORUM": 10,
	"ALL":    20,
}

func (x ConsistencyLevel) String() string {
	return proto.EnumName(ConsistencyLevel_name, int32(x))
}
func (ConsistencyLevel) EnumDescriptor() ([]byte, []int) { return fileDescriptorSandglass, []int{2} }

type LastOffsetRequest_Kind int32

const (
	LastOffsetRequest_Unknown      LastOffsetRequest_Kind = 0
	LastOffsetRequest_Consumed     LastOffsetRequest_Kind = 1
	LastOffsetRequest_Acknowledged LastOffsetRequest_Kind = 2
	LastOffsetRequest_Commited     LastOffsetRequest_Kind = 3
)

var LastOffsetRequest_Kind_name = map[int32]string{
	0: "Unknown",
	1: "Consumed",
	2: "Acknowledged",
	3: "Commited",
}
var LastOffsetRequest_Kind_value = map[string]int32{
	"Unknown":      0,
	"Consumed":     1,
	"Acknowledged": 2,
	"Commited":     3,
}

func (x LastOffsetRequest_Kind) String() string {
	return proto.EnumName(LastOffsetRequest_Kind_name, int32(x))
}
func (LastOffsetRequest_Kind) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorSandglass, []int{12, 0}
}

type Message struct {
	Topic     string                             `protobuf:"bytes,1,opt,name=topic,proto3" json:"topic,omitempty"`
	Partition string                             `protobuf:"bytes,2,opt,name=partition,proto3" json:"partition,omitempty"`
	Index     github_com_celrenheit_sandflake.ID `protobuf:"bytes,3,opt,name=index,proto3,customtype=github.com/celrenheit/sandflake.ID" json:"index"`
	Offset    github_com_celrenheit_sandflake.ID `protobuf:"bytes,4,opt,name=offset,proto3,customtype=github.com/celrenheit/sandflake.ID" json:"offset"`
	Key       []byte                             `protobuf:"bytes,5,opt,name=key,proto3" json:"key,omitempty"`
	Value     []byte                             `protobuf:"bytes,6,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *Message) Reset()                    { *m = Message{} }
func (*Message) ProtoMessage()               {}
func (*Message) Descriptor() ([]byte, []int) { return fileDescriptorSandglass, []int{0} }

func (m *Message) GetTopic() string {
	if m != nil {
		return m.Topic
	}
	return ""
}

func (m *Message) GetPartition() string {
	if m != nil {
		return m.Partition
	}
	return ""
}

func (m *Message) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *Message) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

type DUIDReply struct {
	Id github_com_celrenheit_sandflake.ID `protobuf:"bytes,1,opt,name=id,proto3,customtype=github.com/celrenheit/sandflake.ID" json:"id"`
}

func (m *DUIDReply) Reset()                    { *m = DUIDReply{} }
func (*DUIDReply) ProtoMessage()               {}
func (*DUIDReply) Descriptor() ([]byte, []int) { return fileDescriptorSandglass, []int{1} }

type CreateTopicParams struct {
	Name              string        `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Kind              TopicKind     `protobuf:"varint,2,opt,name=kind,proto3,enum=sandglass.TopicKind" json:"kind,omitempty"`
	ReplicationFactor int32         `protobuf:"varint,3,opt,name=replicationFactor,proto3" json:"replicationFactor,omitempty"`
	NumPartitions     int32         `protobuf:"varint,4,opt,name=numPartitions,proto3" json:"numPartitions,omitempty"`
	StorageDriver     StorageDriver `protobuf:"varint,5,opt,name=storageDriver,proto3,enum=sandglass.StorageDriver" json:"storageDriver,omitempty"`
}

func (m *CreateTopicParams) Reset()                    { *m = CreateTopicParams{} }
func (*CreateTopicParams) ProtoMessage()               {}
func (*CreateTopicParams) Descriptor() ([]byte, []int) { return fileDescriptorSandglass, []int{2} }

func (m *CreateTopicParams) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CreateTopicParams) GetKind() TopicKind {
	if m != nil {
		return m.Kind
	}
	return TopicKind_TimerKind
}

func (m *CreateTopicParams) GetReplicationFactor() int32 {
	if m != nil {
		return m.ReplicationFactor
	}
	return 0
}

func (m *CreateTopicParams) GetNumPartitions() int32 {
	if m != nil {
		return m.NumPartitions
	}
	return 0
}

func (m *CreateTopicParams) GetStorageDriver() StorageDriver {
	if m != nil {
		return m.StorageDriver
	}
	return StorageDriver_RocksDB
}

type TopicReply struct {
	Success bool `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
}

func (m *TopicReply) Reset()                    { *m = TopicReply{} }
func (*TopicReply) ProtoMessage()               {}
func (*TopicReply) Descriptor() ([]byte, []int) { return fileDescriptorSandglass, []int{3} }

func (m *TopicReply) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

type StoreLocallyReply struct {
	Success bool `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
}

func (m *StoreLocallyReply) Reset()                    { *m = StoreLocallyReply{} }
func (*StoreLocallyReply) ProtoMessage()               {}
func (*StoreLocallyReply) Descriptor() ([]byte, []int) { return fileDescriptorSandglass, []int{4} }

func (m *StoreLocallyReply) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

type FetchFromRequest struct {
	Topic     string                             `protobuf:"bytes,1,opt,name=topic,proto3" json:"topic,omitempty"`
	Partition string                             `protobuf:"bytes,2,opt,name=partition,proto3" json:"partition,omitempty"`
	From      github_com_celrenheit_sandflake.ID `protobuf:"bytes,3,opt,name=from,proto3,customtype=github.com/celrenheit/sandflake.ID" json:"from"`
}

func (m *FetchFromRequest) Reset()                    { *m = FetchFromRequest{} }
func (*FetchFromRequest) ProtoMessage()               {}
func (*FetchFromRequest) Descriptor() ([]byte, []int) { return fileDescriptorSandglass, []int{5} }

func (m *FetchFromRequest) GetTopic() string {
	if m != nil {
		return m.Topic
	}
	return ""
}

func (m *FetchFromRequest) GetPartition() string {
	if m != nil {
		return m.Partition
	}
	return ""
}

type FetchRangeRequest struct {
	Topic     string                             `protobuf:"bytes,1,opt,name=topic,proto3" json:"topic,omitempty"`
	Partition string                             `protobuf:"bytes,2,opt,name=partition,proto3" json:"partition,omitempty"`
	From      github_com_celrenheit_sandflake.ID `protobuf:"bytes,3,opt,name=from,proto3,customtype=github.com/celrenheit/sandflake.ID" json:"from"`
	To        github_com_celrenheit_sandflake.ID `protobuf:"bytes,4,opt,name=to,proto3,customtype=github.com/celrenheit/sandflake.ID" json:"to"`
}

func (m *FetchRangeRequest) Reset()                    { *m = FetchRangeRequest{} }
func (*FetchRangeRequest) ProtoMessage()               {}
func (*FetchRangeRequest) Descriptor() ([]byte, []int) { return fileDescriptorSandglass, []int{6} }

func (m *FetchRangeRequest) GetTopic() string {
	if m != nil {
		return m.Topic
	}
	return ""
}

func (m *FetchRangeRequest) GetPartition() string {
	if m != nil {
		return m.Partition
	}
	return ""
}

type GetRequest struct {
	Topic     string `protobuf:"bytes,1,opt,name=topic,proto3" json:"topic,omitempty"`
	Partition string `protobuf:"bytes,2,opt,name=partition,proto3" json:"partition,omitempty"`
	Key       []byte `protobuf:"bytes,3,opt,name=key,proto3" json:"key,omitempty"`
}

func (m *GetRequest) Reset()                    { *m = GetRequest{} }
func (*GetRequest) ProtoMessage()               {}
func (*GetRequest) Descriptor() ([]byte, []int) { return fileDescriptorSandglass, []int{7} }

func (m *GetRequest) GetTopic() string {
	if m != nil {
		return m.Topic
	}
	return ""
}

func (m *GetRequest) GetPartition() string {
	if m != nil {
		return m.Partition
	}
	return ""
}

func (m *GetRequest) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

type ConsumeFromGroupRequest struct {
	Topic             string `protobuf:"bytes,1,opt,name=topic,proto3" json:"topic,omitempty"`
	Partition         string `protobuf:"bytes,2,opt,name=partition,proto3" json:"partition,omitempty"`
	ConsumerGroupName string `protobuf:"bytes,3,opt,name=consumerGroupName,proto3" json:"consumerGroupName,omitempty"`
	ConsumerName      string `protobuf:"bytes,4,opt,name=consumerName,proto3" json:"consumerName,omitempty"`
}

func (m *ConsumeFromGroupRequest) Reset()                    { *m = ConsumeFromGroupRequest{} }
func (*ConsumeFromGroupRequest) ProtoMessage()               {}
func (*ConsumeFromGroupRequest) Descriptor() ([]byte, []int) { return fileDescriptorSandglass, []int{8} }

func (m *ConsumeFromGroupRequest) GetTopic() string {
	if m != nil {
		return m.Topic
	}
	return ""
}

func (m *ConsumeFromGroupRequest) GetPartition() string {
	if m != nil {
		return m.Partition
	}
	return ""
}

func (m *ConsumeFromGroupRequest) GetConsumerGroupName() string {
	if m != nil {
		return m.ConsumerGroupName
	}
	return ""
}

func (m *ConsumeFromGroupRequest) GetConsumerName() string {
	if m != nil {
		return m.ConsumerName
	}
	return ""
}

type OffsetChangeRequest struct {
	Topic         string                             `protobuf:"bytes,1,opt,name=topic,proto3" json:"topic,omitempty"`
	Partition     string                             `protobuf:"bytes,2,opt,name=partition,proto3" json:"partition,omitempty"`
	ConsumerGroup string                             `protobuf:"bytes,3,opt,name=consumerGroup,proto3" json:"consumerGroup,omitempty"`
	ConsumerName  string                             `protobuf:"bytes,4,opt,name=consumerName,proto3" json:"consumerName,omitempty"`
	Offset        github_com_celrenheit_sandflake.ID `protobuf:"bytes,5,opt,name=offset,proto3,customtype=github.com/celrenheit/sandflake.ID" json:"offset"`
}

func (m *OffsetChangeRequest) Reset()                    { *m = OffsetChangeRequest{} }
func (*OffsetChangeRequest) ProtoMessage()               {}
func (*OffsetChangeRequest) Descriptor() ([]byte, []int) { return fileDescriptorSandglass, []int{9} }

func (m *OffsetChangeRequest) GetTopic() string {
	if m != nil {
		return m.Topic
	}
	return ""
}

func (m *OffsetChangeRequest) GetPartition() string {
	if m != nil {
		return m.Partition
	}
	return ""
}

func (m *OffsetChangeRequest) GetConsumerGroup() string {
	if m != nil {
		return m.ConsumerGroup
	}
	return ""
}

func (m *OffsetChangeRequest) GetConsumerName() string {
	if m != nil {
		return m.ConsumerName
	}
	return ""
}

type OffsetChangeReply struct {
	Success bool `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
}

func (m *OffsetChangeReply) Reset()                    { *m = OffsetChangeReply{} }
func (*OffsetChangeReply) ProtoMessage()               {}
func (*OffsetChangeReply) Descriptor() ([]byte, []int) { return fileDescriptorSandglass, []int{10} }

func (m *OffsetChangeReply) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

type LastOffsetReply struct {
	Offset github_com_celrenheit_sandflake.ID `protobuf:"bytes,1,opt,name=offset,proto3,customtype=github.com/celrenheit/sandflake.ID" json:"offset"`
}

func (m *LastOffsetReply) Reset()                    { *m = LastOffsetReply{} }
func (*LastOffsetReply) ProtoMessage()               {}
func (*LastOffsetReply) Descriptor() ([]byte, []int) { return fileDescriptorSandglass, []int{11} }

type LastOffsetRequest struct {
	Topic         string                 `protobuf:"bytes,1,opt,name=topic,proto3" json:"topic,omitempty"`
	Partition     string                 `protobuf:"bytes,2,opt,name=partition,proto3" json:"partition,omitempty"`
	ConsumerGroup string                 `protobuf:"bytes,3,opt,name=consumerGroup,proto3" json:"consumerGroup,omitempty"`
	ConsumerName  string                 `protobuf:"bytes,4,opt,name=consumerName,proto3" json:"consumerName,omitempty"`
	Kind          LastOffsetRequest_Kind `protobuf:"varint,5,opt,name=kind,proto3,enum=sandglass.LastOffsetRequest_Kind" json:"kind,omitempty"`
}

func (m *LastOffsetRequest) Reset()                    { *m = LastOffsetRequest{} }
func (*LastOffsetRequest) ProtoMessage()               {}
func (*LastOffsetRequest) Descriptor() ([]byte, []int) { return fileDescriptorSandglass, []int{12} }

func (m *LastOffsetRequest) GetTopic() string {
	if m != nil {
		return m.Topic
	}
	return ""
}

func (m *LastOffsetRequest) GetPartition() string {
	if m != nil {
		return m.Partition
	}
	return ""
}

func (m *LastOffsetRequest) GetConsumerGroup() string {
	if m != nil {
		return m.ConsumerGroup
	}
	return ""
}

func (m *LastOffsetRequest) GetConsumerName() string {
	if m != nil {
		return m.ConsumerName
	}
	return ""
}

func (m *LastOffsetRequest) GetKind() LastOffsetRequest_Kind {
	if m != nil {
		return m.Kind
	}
	return LastOffsetRequest_Unknown
}

type FetchFromSyncRequest struct {
	Topic     string `protobuf:"bytes,1,opt,name=topic,proto3" json:"topic,omitempty"`
	Partition string `protobuf:"bytes,2,opt,name=partition,proto3" json:"partition,omitempty"`
	From      []byte `protobuf:"bytes,3,opt,name=from,proto3" json:"from,omitempty"`
}

func (m *FetchFromSyncRequest) Reset()                    { *m = FetchFromSyncRequest{} }
func (*FetchFromSyncRequest) ProtoMessage()               {}
func (*FetchFromSyncRequest) Descriptor() ([]byte, []int) { return fileDescriptorSandglass, []int{13} }

func (m *FetchFromSyncRequest) GetTopic() string {
	if m != nil {
		return m.Topic
	}
	return ""
}

func (m *FetchFromSyncRequest) GetPartition() string {
	if m != nil {
		return m.Partition
	}
	return ""
}

func (m *FetchFromSyncRequest) GetFrom() []byte {
	if m != nil {
		return m.From
	}
	return nil
}

type HasResponse struct {
	Exists bool `protobuf:"varint,1,opt,name=exists,proto3" json:"exists,omitempty"`
}

func (m *HasResponse) Reset()                    { *m = HasResponse{} }
func (*HasResponse) ProtoMessage()               {}
func (*HasResponse) Descriptor() ([]byte, []int) { return fileDescriptorSandglass, []int{14} }

func (m *HasResponse) GetExists() bool {
	if m != nil {
		return m.Exists
	}
	return false
}

type SyncRequest struct {
	Topics map[string]*SyncRequest_SyncRequestTopic `protobuf:"bytes,1,rep,name=topics" json:"topics,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *SyncRequest) Reset()                    { *m = SyncRequest{} }
func (*SyncRequest) ProtoMessage()               {}
func (*SyncRequest) Descriptor() ([]byte, []int) { return fileDescriptorSandglass, []int{15} }

func (m *SyncRequest) GetTopics() map[string]*SyncRequest_SyncRequestTopic {
	if m != nil {
		return m.Topics
	}
	return nil
}

type SyncRequest_SyncRequestTopic struct {
	Partitions []string `protobuf:"bytes,1,rep,name=partitions" json:"partitions,omitempty"`
}

func (m *SyncRequest_SyncRequestTopic) Reset()      { *m = SyncRequest_SyncRequestTopic{} }
func (*SyncRequest_SyncRequestTopic) ProtoMessage() {}
func (*SyncRequest_SyncRequestTopic) Descriptor() ([]byte, []int) {
	return fileDescriptorSandglass, []int{15, 0}
}

func (m *SyncRequest_SyncRequestTopic) GetPartitions() []string {
	if m != nil {
		return m.Partitions
	}
	return nil
}

type SyncResponse struct {
	Topics map[string]*SyncResponse_SyncResponseTopic `protobuf:"bytes,1,rep,name=topics" json:"topics,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *SyncResponse) Reset()                    { *m = SyncResponse{} }
func (*SyncResponse) ProtoMessage()               {}
func (*SyncResponse) Descriptor() ([]byte, []int) { return fileDescriptorSandglass, []int{16} }

func (m *SyncResponse) GetTopics() map[string]*SyncResponse_SyncResponseTopic {
	if m != nil {
		return m.Topics
	}
	return nil
}

type SyncResponse_SyncResponseTopic struct {
	Partitions map[string]*Message `protobuf:"bytes,1,rep,name=partitions" json:"partitions,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *SyncResponse_SyncResponseTopic) Reset()      { *m = SyncResponse_SyncResponseTopic{} }
func (*SyncResponse_SyncResponseTopic) ProtoMessage() {}
func (*SyncResponse_SyncResponseTopic) Descriptor() ([]byte, []int) {
	return fileDescriptorSandglass, []int{16, 0}
}

func (m *SyncResponse_SyncResponseTopic) GetPartitions() map[string]*Message {
	if m != nil {
		return m.Partitions
	}
	return nil
}

func init() {
	proto.RegisterType((*Message)(nil), "sandglass.Message")
	proto.RegisterType((*DUIDReply)(nil), "sandglass.DUIDReply")
	proto.RegisterType((*CreateTopicParams)(nil), "sandglass.CreateTopicParams")
	proto.RegisterType((*TopicReply)(nil), "sandglass.TopicReply")
	proto.RegisterType((*StoreLocallyReply)(nil), "sandglass.StoreLocallyReply")
	proto.RegisterType((*FetchFromRequest)(nil), "sandglass.FetchFromRequest")
	proto.RegisterType((*FetchRangeRequest)(nil), "sandglass.FetchRangeRequest")
	proto.RegisterType((*GetRequest)(nil), "sandglass.GetRequest")
	proto.RegisterType((*ConsumeFromGroupRequest)(nil), "sandglass.ConsumeFromGroupRequest")
	proto.RegisterType((*OffsetChangeRequest)(nil), "sandglass.OffsetChangeRequest")
	proto.RegisterType((*OffsetChangeReply)(nil), "sandglass.OffsetChangeReply")
	proto.RegisterType((*LastOffsetReply)(nil), "sandglass.LastOffsetReply")
	proto.RegisterType((*LastOffsetRequest)(nil), "sandglass.LastOffsetRequest")
	proto.RegisterType((*FetchFromSyncRequest)(nil), "sandglass.FetchFromSyncRequest")
	proto.RegisterType((*HasResponse)(nil), "sandglass.HasResponse")
	proto.RegisterType((*SyncRequest)(nil), "sandglass.SyncRequest")
	proto.RegisterType((*SyncRequest_SyncRequestTopic)(nil), "sandglass.SyncRequest.SyncRequestTopic")
	proto.RegisterType((*SyncResponse)(nil), "sandglass.SyncResponse")
	proto.RegisterType((*SyncResponse_SyncResponseTopic)(nil), "sandglass.SyncResponse.SyncResponseTopic")
	proto.RegisterEnum("sandglass.TopicKind", TopicKind_name, TopicKind_value)
	proto.RegisterEnum("sandglass.StorageDriver", StorageDriver_name, StorageDriver_value)
	proto.RegisterEnum("sandglass.ConsistencyLevel", ConsistencyLevel_name, ConsistencyLevel_value)
	proto.RegisterEnum("sandglass.LastOffsetRequest_Kind", LastOffsetRequest_Kind_name, LastOffsetRequest_Kind_value)
}
func (this *Message) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Message)
	if !ok {
		that2, ok := that.(Message)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Topic != that1.Topic {
		return false
	}
	if this.Partition != that1.Partition {
		return false
	}
	if !this.Index.Equal(that1.Index) {
		return false
	}
	if !this.Offset.Equal(that1.Offset) {
		return false
	}
	if !bytes.Equal(this.Key, that1.Key) {
		return false
	}
	if !bytes.Equal(this.Value, that1.Value) {
		return false
	}
	return true
}
func (this *DUIDReply) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*DUIDReply)
	if !ok {
		that2, ok := that.(DUIDReply)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Id.Equal(that1.Id) {
		return false
	}
	return true
}
func (this *CreateTopicParams) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*CreateTopicParams)
	if !ok {
		that2, ok := that.(CreateTopicParams)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Kind != that1.Kind {
		return false
	}
	if this.ReplicationFactor != that1.ReplicationFactor {
		return false
	}
	if this.NumPartitions != that1.NumPartitions {
		return false
	}
	if this.StorageDriver != that1.StorageDriver {
		return false
	}
	return true
}
func (this *TopicReply) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*TopicReply)
	if !ok {
		that2, ok := that.(TopicReply)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Success != that1.Success {
		return false
	}
	return true
}
func (this *StoreLocallyReply) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*StoreLocallyReply)
	if !ok {
		that2, ok := that.(StoreLocallyReply)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Success != that1.Success {
		return false
	}
	return true
}
func (this *FetchFromRequest) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*FetchFromRequest)
	if !ok {
		that2, ok := that.(FetchFromRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Topic != that1.Topic {
		return false
	}
	if this.Partition != that1.Partition {
		return false
	}
	if !this.From.Equal(that1.From) {
		return false
	}
	return true
}
func (this *FetchRangeRequest) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*FetchRangeRequest)
	if !ok {
		that2, ok := that.(FetchRangeRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Topic != that1.Topic {
		return false
	}
	if this.Partition != that1.Partition {
		return false
	}
	if !this.From.Equal(that1.From) {
		return false
	}
	if !this.To.Equal(that1.To) {
		return false
	}
	return true
}
func (this *GetRequest) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*GetRequest)
	if !ok {
		that2, ok := that.(GetRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Topic != that1.Topic {
		return false
	}
	if this.Partition != that1.Partition {
		return false
	}
	if !bytes.Equal(this.Key, that1.Key) {
		return false
	}
	return true
}
func (this *ConsumeFromGroupRequest) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ConsumeFromGroupRequest)
	if !ok {
		that2, ok := that.(ConsumeFromGroupRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Topic != that1.Topic {
		return false
	}
	if this.Partition != that1.Partition {
		return false
	}
	if this.ConsumerGroupName != that1.ConsumerGroupName {
		return false
	}
	if this.ConsumerName != that1.ConsumerName {
		return false
	}
	return true
}
func (this *OffsetChangeRequest) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*OffsetChangeRequest)
	if !ok {
		that2, ok := that.(OffsetChangeRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Topic != that1.Topic {
		return false
	}
	if this.Partition != that1.Partition {
		return false
	}
	if this.ConsumerGroup != that1.ConsumerGroup {
		return false
	}
	if this.ConsumerName != that1.ConsumerName {
		return false
	}
	if !this.Offset.Equal(that1.Offset) {
		return false
	}
	return true
}
func (this *OffsetChangeReply) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*OffsetChangeReply)
	if !ok {
		that2, ok := that.(OffsetChangeReply)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Success != that1.Success {
		return false
	}
	return true
}
func (this *LastOffsetReply) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*LastOffsetReply)
	if !ok {
		that2, ok := that.(LastOffsetReply)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Offset.Equal(that1.Offset) {
		return false
	}
	return true
}
func (this *LastOffsetRequest) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*LastOffsetRequest)
	if !ok {
		that2, ok := that.(LastOffsetRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Topic != that1.Topic {
		return false
	}
	if this.Partition != that1.Partition {
		return false
	}
	if this.ConsumerGroup != that1.ConsumerGroup {
		return false
	}
	if this.ConsumerName != that1.ConsumerName {
		return false
	}
	if this.Kind != that1.Kind {
		return false
	}
	return true
}
func (this *FetchFromSyncRequest) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*FetchFromSyncRequest)
	if !ok {
		that2, ok := that.(FetchFromSyncRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Topic != that1.Topic {
		return false
	}
	if this.Partition != that1.Partition {
		return false
	}
	if !bytes.Equal(this.From, that1.From) {
		return false
	}
	return true
}
func (this *HasResponse) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*HasResponse)
	if !ok {
		that2, ok := that.(HasResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Exists != that1.Exists {
		return false
	}
	return true
}
func (this *SyncRequest) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*SyncRequest)
	if !ok {
		that2, ok := that.(SyncRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.Topics) != len(that1.Topics) {
		return false
	}
	for i := range this.Topics {
		if !this.Topics[i].Equal(that1.Topics[i]) {
			return false
		}
	}
	return true
}
func (this *SyncRequest_SyncRequestTopic) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*SyncRequest_SyncRequestTopic)
	if !ok {
		that2, ok := that.(SyncRequest_SyncRequestTopic)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.Partitions) != len(that1.Partitions) {
		return false
	}
	for i := range this.Partitions {
		if this.Partitions[i] != that1.Partitions[i] {
			return false
		}
	}
	return true
}
func (this *SyncResponse) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*SyncResponse)
	if !ok {
		that2, ok := that.(SyncResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.Topics) != len(that1.Topics) {
		return false
	}
	for i := range this.Topics {
		if !this.Topics[i].Equal(that1.Topics[i]) {
			return false
		}
	}
	return true
}
func (this *SyncResponse_SyncResponseTopic) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*SyncResponse_SyncResponseTopic)
	if !ok {
		that2, ok := that.(SyncResponse_SyncResponseTopic)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.Partitions) != len(that1.Partitions) {
		return false
	}
	for i := range this.Partitions {
		if !this.Partitions[i].Equal(that1.Partitions[i]) {
			return false
		}
	}
	return true
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for BrokerService service

type BrokerServiceClient interface {
	CreateTopic(ctx context.Context, in *CreateTopicParams, opts ...grpc.CallOption) (*TopicReply, error)
	Publish(ctx context.Context, in *Message, opts ...grpc.CallOption) (*DUIDReply, error)
	StoreMessageLocally(ctx context.Context, in *Message, opts ...grpc.CallOption) (*StoreLocallyReply, error)
	FetchFrom(ctx context.Context, in *FetchFromRequest, opts ...grpc.CallOption) (BrokerService_FetchFromClient, error)
	FetchRange(ctx context.Context, in *FetchRangeRequest, opts ...grpc.CallOption) (BrokerService_FetchRangeClient, error)
	GetByKey(ctx context.Context, in *GetRequest, opts ...grpc.CallOption) (*Message, error)
	HasKey(ctx context.Context, in *GetRequest, opts ...grpc.CallOption) (*HasResponse, error)
	StoreMessagesStream(ctx context.Context, opts ...grpc.CallOption) (BrokerService_StoreMessagesStreamClient, error)
	ConsumeFromGroup(ctx context.Context, in *ConsumeFromGroupRequest, opts ...grpc.CallOption) (BrokerService_ConsumeFromGroupClient, error)
	Acknowledge(ctx context.Context, in *OffsetChangeRequest, opts ...grpc.CallOption) (*OffsetChangeReply, error)
	Commit(ctx context.Context, in *OffsetChangeRequest, opts ...grpc.CallOption) (*OffsetChangeReply, error)
	LastOffset(ctx context.Context, in *LastOffsetRequest, opts ...grpc.CallOption) (*LastOffsetReply, error)
	FetchFromSync(ctx context.Context, in *FetchFromSyncRequest, opts ...grpc.CallOption) (BrokerService_FetchFromSyncClient, error)
}

type brokerServiceClient struct {
	cc *grpc.ClientConn
}

func NewBrokerServiceClient(cc *grpc.ClientConn) BrokerServiceClient {
	return &brokerServiceClient{cc}
}

func (c *brokerServiceClient) CreateTopic(ctx context.Context, in *CreateTopicParams, opts ...grpc.CallOption) (*TopicReply, error) {
	out := new(TopicReply)
	err := grpc.Invoke(ctx, "/sandglass.BrokerService/CreateTopic", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *brokerServiceClient) Publish(ctx context.Context, in *Message, opts ...grpc.CallOption) (*DUIDReply, error) {
	out := new(DUIDReply)
	err := grpc.Invoke(ctx, "/sandglass.BrokerService/Publish", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *brokerServiceClient) StoreMessageLocally(ctx context.Context, in *Message, opts ...grpc.CallOption) (*StoreLocallyReply, error) {
	out := new(StoreLocallyReply)
	err := grpc.Invoke(ctx, "/sandglass.BrokerService/StoreMessageLocally", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *brokerServiceClient) FetchFrom(ctx context.Context, in *FetchFromRequest, opts ...grpc.CallOption) (BrokerService_FetchFromClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_BrokerService_serviceDesc.Streams[0], c.cc, "/sandglass.BrokerService/FetchFrom", opts...)
	if err != nil {
		return nil, err
	}
	x := &brokerServiceFetchFromClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type BrokerService_FetchFromClient interface {
	Recv() (*Message, error)
	grpc.ClientStream
}

type brokerServiceFetchFromClient struct {
	grpc.ClientStream
}

func (x *brokerServiceFetchFromClient) Recv() (*Message, error) {
	m := new(Message)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *brokerServiceClient) FetchRange(ctx context.Context, in *FetchRangeRequest, opts ...grpc.CallOption) (BrokerService_FetchRangeClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_BrokerService_serviceDesc.Streams[1], c.cc, "/sandglass.BrokerService/FetchRange", opts...)
	if err != nil {
		return nil, err
	}
	x := &brokerServiceFetchRangeClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type BrokerService_FetchRangeClient interface {
	Recv() (*Message, error)
	grpc.ClientStream
}

type brokerServiceFetchRangeClient struct {
	grpc.ClientStream
}

func (x *brokerServiceFetchRangeClient) Recv() (*Message, error) {
	m := new(Message)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *brokerServiceClient) GetByKey(ctx context.Context, in *GetRequest, opts ...grpc.CallOption) (*Message, error) {
	out := new(Message)
	err := grpc.Invoke(ctx, "/sandglass.BrokerService/GetByKey", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *brokerServiceClient) HasKey(ctx context.Context, in *GetRequest, opts ...grpc.CallOption) (*HasResponse, error) {
	out := new(HasResponse)
	err := grpc.Invoke(ctx, "/sandglass.BrokerService/HasKey", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *brokerServiceClient) StoreMessagesStream(ctx context.Context, opts ...grpc.CallOption) (BrokerService_StoreMessagesStreamClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_BrokerService_serviceDesc.Streams[2], c.cc, "/sandglass.BrokerService/StoreMessagesStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &brokerServiceStoreMessagesStreamClient{stream}
	return x, nil
}

type BrokerService_StoreMessagesStreamClient interface {
	Send(*Message) error
	CloseAndRecv() (*StoreLocallyReply, error)
	grpc.ClientStream
}

type brokerServiceStoreMessagesStreamClient struct {
	grpc.ClientStream
}

func (x *brokerServiceStoreMessagesStreamClient) Send(m *Message) error {
	return x.ClientStream.SendMsg(m)
}

func (x *brokerServiceStoreMessagesStreamClient) CloseAndRecv() (*StoreLocallyReply, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(StoreLocallyReply)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *brokerServiceClient) ConsumeFromGroup(ctx context.Context, in *ConsumeFromGroupRequest, opts ...grpc.CallOption) (BrokerService_ConsumeFromGroupClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_BrokerService_serviceDesc.Streams[3], c.cc, "/sandglass.BrokerService/ConsumeFromGroup", opts...)
	if err != nil {
		return nil, err
	}
	x := &brokerServiceConsumeFromGroupClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type BrokerService_ConsumeFromGroupClient interface {
	Recv() (*Message, error)
	grpc.ClientStream
}

type brokerServiceConsumeFromGroupClient struct {
	grpc.ClientStream
}

func (x *brokerServiceConsumeFromGroupClient) Recv() (*Message, error) {
	m := new(Message)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *brokerServiceClient) Acknowledge(ctx context.Context, in *OffsetChangeRequest, opts ...grpc.CallOption) (*OffsetChangeReply, error) {
	out := new(OffsetChangeReply)
	err := grpc.Invoke(ctx, "/sandglass.BrokerService/Acknowledge", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *brokerServiceClient) Commit(ctx context.Context, in *OffsetChangeRequest, opts ...grpc.CallOption) (*OffsetChangeReply, error) {
	out := new(OffsetChangeReply)
	err := grpc.Invoke(ctx, "/sandglass.BrokerService/Commit", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *brokerServiceClient) LastOffset(ctx context.Context, in *LastOffsetRequest, opts ...grpc.CallOption) (*LastOffsetReply, error) {
	out := new(LastOffsetReply)
	err := grpc.Invoke(ctx, "/sandglass.BrokerService/LastOffset", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *brokerServiceClient) FetchFromSync(ctx context.Context, in *FetchFromSyncRequest, opts ...grpc.CallOption) (BrokerService_FetchFromSyncClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_BrokerService_serviceDesc.Streams[4], c.cc, "/sandglass.BrokerService/FetchFromSync", opts...)
	if err != nil {
		return nil, err
	}
	x := &brokerServiceFetchFromSyncClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type BrokerService_FetchFromSyncClient interface {
	Recv() (*Message, error)
	grpc.ClientStream
}

type brokerServiceFetchFromSyncClient struct {
	grpc.ClientStream
}

func (x *brokerServiceFetchFromSyncClient) Recv() (*Message, error) {
	m := new(Message)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for BrokerService service

type BrokerServiceServer interface {
	CreateTopic(context.Context, *CreateTopicParams) (*TopicReply, error)
	Publish(context.Context, *Message) (*DUIDReply, error)
	StoreMessageLocally(context.Context, *Message) (*StoreLocallyReply, error)
	FetchFrom(*FetchFromRequest, BrokerService_FetchFromServer) error
	FetchRange(*FetchRangeRequest, BrokerService_FetchRangeServer) error
	GetByKey(context.Context, *GetRequest) (*Message, error)
	HasKey(context.Context, *GetRequest) (*HasResponse, error)
	StoreMessagesStream(BrokerService_StoreMessagesStreamServer) error
	ConsumeFromGroup(*ConsumeFromGroupRequest, BrokerService_ConsumeFromGroupServer) error
	Acknowledge(context.Context, *OffsetChangeRequest) (*OffsetChangeReply, error)
	Commit(context.Context, *OffsetChangeRequest) (*OffsetChangeReply, error)
	LastOffset(context.Context, *LastOffsetRequest) (*LastOffsetReply, error)
	FetchFromSync(*FetchFromSyncRequest, BrokerService_FetchFromSyncServer) error
}

func RegisterBrokerServiceServer(s *grpc.Server, srv BrokerServiceServer) {
	s.RegisterService(&_BrokerService_serviceDesc, srv)
}

func _BrokerService_CreateTopic_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateTopicParams)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BrokerServiceServer).CreateTopic(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sandglass.BrokerService/CreateTopic",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BrokerServiceServer).CreateTopic(ctx, req.(*CreateTopicParams))
	}
	return interceptor(ctx, in, info, handler)
}

func _BrokerService_Publish_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Message)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BrokerServiceServer).Publish(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sandglass.BrokerService/Publish",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BrokerServiceServer).Publish(ctx, req.(*Message))
	}
	return interceptor(ctx, in, info, handler)
}

func _BrokerService_StoreMessageLocally_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Message)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BrokerServiceServer).StoreMessageLocally(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sandglass.BrokerService/StoreMessageLocally",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BrokerServiceServer).StoreMessageLocally(ctx, req.(*Message))
	}
	return interceptor(ctx, in, info, handler)
}

func _BrokerService_FetchFrom_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(FetchFromRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(BrokerServiceServer).FetchFrom(m, &brokerServiceFetchFromServer{stream})
}

type BrokerService_FetchFromServer interface {
	Send(*Message) error
	grpc.ServerStream
}

type brokerServiceFetchFromServer struct {
	grpc.ServerStream
}

func (x *brokerServiceFetchFromServer) Send(m *Message) error {
	return x.ServerStream.SendMsg(m)
}

func _BrokerService_FetchRange_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(FetchRangeRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(BrokerServiceServer).FetchRange(m, &brokerServiceFetchRangeServer{stream})
}

type BrokerService_FetchRangeServer interface {
	Send(*Message) error
	grpc.ServerStream
}

type brokerServiceFetchRangeServer struct {
	grpc.ServerStream
}

func (x *brokerServiceFetchRangeServer) Send(m *Message) error {
	return x.ServerStream.SendMsg(m)
}

func _BrokerService_GetByKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BrokerServiceServer).GetByKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sandglass.BrokerService/GetByKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BrokerServiceServer).GetByKey(ctx, req.(*GetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BrokerService_HasKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BrokerServiceServer).HasKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sandglass.BrokerService/HasKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BrokerServiceServer).HasKey(ctx, req.(*GetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BrokerService_StoreMessagesStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(BrokerServiceServer).StoreMessagesStream(&brokerServiceStoreMessagesStreamServer{stream})
}

type BrokerService_StoreMessagesStreamServer interface {
	SendAndClose(*StoreLocallyReply) error
	Recv() (*Message, error)
	grpc.ServerStream
}

type brokerServiceStoreMessagesStreamServer struct {
	grpc.ServerStream
}

func (x *brokerServiceStoreMessagesStreamServer) SendAndClose(m *StoreLocallyReply) error {
	return x.ServerStream.SendMsg(m)
}

func (x *brokerServiceStoreMessagesStreamServer) Recv() (*Message, error) {
	m := new(Message)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _BrokerService_ConsumeFromGroup_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ConsumeFromGroupRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(BrokerServiceServer).ConsumeFromGroup(m, &brokerServiceConsumeFromGroupServer{stream})
}

type BrokerService_ConsumeFromGroupServer interface {
	Send(*Message) error
	grpc.ServerStream
}

type brokerServiceConsumeFromGroupServer struct {
	grpc.ServerStream
}

func (x *brokerServiceConsumeFromGroupServer) Send(m *Message) error {
	return x.ServerStream.SendMsg(m)
}

func _BrokerService_Acknowledge_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OffsetChangeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BrokerServiceServer).Acknowledge(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sandglass.BrokerService/Acknowledge",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BrokerServiceServer).Acknowledge(ctx, req.(*OffsetChangeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BrokerService_Commit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OffsetChangeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BrokerServiceServer).Commit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sandglass.BrokerService/Commit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BrokerServiceServer).Commit(ctx, req.(*OffsetChangeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BrokerService_LastOffset_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LastOffsetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BrokerServiceServer).LastOffset(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sandglass.BrokerService/LastOffset",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BrokerServiceServer).LastOffset(ctx, req.(*LastOffsetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BrokerService_FetchFromSync_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(FetchFromSyncRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(BrokerServiceServer).FetchFromSync(m, &brokerServiceFetchFromSyncServer{stream})
}

type BrokerService_FetchFromSyncServer interface {
	Send(*Message) error
	grpc.ServerStream
}

type brokerServiceFetchFromSyncServer struct {
	grpc.ServerStream
}

func (x *brokerServiceFetchFromSyncServer) Send(m *Message) error {
	return x.ServerStream.SendMsg(m)
}

var _BrokerService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sandglass.BrokerService",
	HandlerType: (*BrokerServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateTopic",
			Handler:    _BrokerService_CreateTopic_Handler,
		},
		{
			MethodName: "Publish",
			Handler:    _BrokerService_Publish_Handler,
		},
		{
			MethodName: "StoreMessageLocally",
			Handler:    _BrokerService_StoreMessageLocally_Handler,
		},
		{
			MethodName: "GetByKey",
			Handler:    _BrokerService_GetByKey_Handler,
		},
		{
			MethodName: "HasKey",
			Handler:    _BrokerService_HasKey_Handler,
		},
		{
			MethodName: "Acknowledge",
			Handler:    _BrokerService_Acknowledge_Handler,
		},
		{
			MethodName: "Commit",
			Handler:    _BrokerService_Commit_Handler,
		},
		{
			MethodName: "LastOffset",
			Handler:    _BrokerService_LastOffset_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "FetchFrom",
			Handler:       _BrokerService_FetchFrom_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "FetchRange",
			Handler:       _BrokerService_FetchRange_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StoreMessagesStream",
			Handler:       _BrokerService_StoreMessagesStream_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "ConsumeFromGroup",
			Handler:       _BrokerService_ConsumeFromGroup_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "FetchFromSync",
			Handler:       _BrokerService_FetchFromSync_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "sandglass.proto",
}

func (m *Message) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Message) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Topic) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(len(m.Topic)))
		i += copy(dAtA[i:], m.Topic)
	}
	if len(m.Partition) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(len(m.Partition)))
		i += copy(dAtA[i:], m.Partition)
	}
	dAtA[i] = 0x1a
	i++
	i = encodeVarintSandglass(dAtA, i, uint64(m.Index.Size()))
	n1, err := m.Index.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	dAtA[i] = 0x22
	i++
	i = encodeVarintSandglass(dAtA, i, uint64(m.Offset.Size()))
	n2, err := m.Offset.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	if len(m.Key) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if len(m.Value) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	return i, nil
}

func (m *DUIDReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DUIDReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintSandglass(dAtA, i, uint64(m.Id.Size()))
	n3, err := m.Id.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	return i, nil
}

func (m *CreateTopicParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateTopicParams) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Kind != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(m.Kind))
	}
	if m.ReplicationFactor != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(m.ReplicationFactor))
	}
	if m.NumPartitions != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(m.NumPartitions))
	}
	if m.StorageDriver != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(m.StorageDriver))
	}
	return i, nil
}

func (m *TopicReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TopicReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Success {
		dAtA[i] = 0x8
		i++
		if m.Success {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *StoreLocallyReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StoreLocallyReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Success {
		dAtA[i] = 0x8
		i++
		if m.Success {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *FetchFromRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FetchFromRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Topic) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(len(m.Topic)))
		i += copy(dAtA[i:], m.Topic)
	}
	if len(m.Partition) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(len(m.Partition)))
		i += copy(dAtA[i:], m.Partition)
	}
	dAtA[i] = 0x1a
	i++
	i = encodeVarintSandglass(dAtA, i, uint64(m.From.Size()))
	n4, err := m.From.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n4
	return i, nil
}

func (m *FetchRangeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FetchRangeRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Topic) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(len(m.Topic)))
		i += copy(dAtA[i:], m.Topic)
	}
	if len(m.Partition) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(len(m.Partition)))
		i += copy(dAtA[i:], m.Partition)
	}
	dAtA[i] = 0x1a
	i++
	i = encodeVarintSandglass(dAtA, i, uint64(m.From.Size()))
	n5, err := m.From.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n5
	dAtA[i] = 0x22
	i++
	i = encodeVarintSandglass(dAtA, i, uint64(m.To.Size()))
	n6, err := m.To.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n6
	return i, nil
}

func (m *GetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Topic) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(len(m.Topic)))
		i += copy(dAtA[i:], m.Topic)
	}
	if len(m.Partition) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(len(m.Partition)))
		i += copy(dAtA[i:], m.Partition)
	}
	if len(m.Key) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	return i, nil
}

func (m *ConsumeFromGroupRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConsumeFromGroupRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Topic) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(len(m.Topic)))
		i += copy(dAtA[i:], m.Topic)
	}
	if len(m.Partition) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(len(m.Partition)))
		i += copy(dAtA[i:], m.Partition)
	}
	if len(m.ConsumerGroupName) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(len(m.ConsumerGroupName)))
		i += copy(dAtA[i:], m.ConsumerGroupName)
	}
	if len(m.ConsumerName) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(len(m.ConsumerName)))
		i += copy(dAtA[i:], m.ConsumerName)
	}
	return i, nil
}

func (m *OffsetChangeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OffsetChangeRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Topic) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(len(m.Topic)))
		i += copy(dAtA[i:], m.Topic)
	}
	if len(m.Partition) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(len(m.Partition)))
		i += copy(dAtA[i:], m.Partition)
	}
	if len(m.ConsumerGroup) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(len(m.ConsumerGroup)))
		i += copy(dAtA[i:], m.ConsumerGroup)
	}
	if len(m.ConsumerName) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(len(m.ConsumerName)))
		i += copy(dAtA[i:], m.ConsumerName)
	}
	dAtA[i] = 0x2a
	i++
	i = encodeVarintSandglass(dAtA, i, uint64(m.Offset.Size()))
	n7, err := m.Offset.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n7
	return i, nil
}

func (m *OffsetChangeReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OffsetChangeReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Success {
		dAtA[i] = 0x8
		i++
		if m.Success {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *LastOffsetReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LastOffsetReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintSandglass(dAtA, i, uint64(m.Offset.Size()))
	n8, err := m.Offset.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n8
	return i, nil
}

func (m *LastOffsetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LastOffsetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Topic) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(len(m.Topic)))
		i += copy(dAtA[i:], m.Topic)
	}
	if len(m.Partition) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(len(m.Partition)))
		i += copy(dAtA[i:], m.Partition)
	}
	if len(m.ConsumerGroup) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(len(m.ConsumerGroup)))
		i += copy(dAtA[i:], m.ConsumerGroup)
	}
	if len(m.ConsumerName) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(len(m.ConsumerName)))
		i += copy(dAtA[i:], m.ConsumerName)
	}
	if m.Kind != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(m.Kind))
	}
	return i, nil
}

func (m *FetchFromSyncRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FetchFromSyncRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Topic) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(len(m.Topic)))
		i += copy(dAtA[i:], m.Topic)
	}
	if len(m.Partition) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(len(m.Partition)))
		i += copy(dAtA[i:], m.Partition)
	}
	if len(m.From) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(len(m.From)))
		i += copy(dAtA[i:], m.From)
	}
	return i, nil
}

func (m *HasResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HasResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Exists {
		dAtA[i] = 0x8
		i++
		if m.Exists {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *SyncRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SyncRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Topics) > 0 {
		for k, _ := range m.Topics {
			dAtA[i] = 0xa
			i++
			v := m.Topics[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovSandglass(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovSandglass(uint64(len(k))) + msgSize
			i = encodeVarintSandglass(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintSandglass(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintSandglass(dAtA, i, uint64(v.Size()))
				n9, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n9
			}
		}
	}
	return i, nil
}

func (m *SyncRequest_SyncRequestTopic) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SyncRequest_SyncRequestTopic) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Partitions) > 0 {
		for _, s := range m.Partitions {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *SyncResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SyncResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Topics) > 0 {
		for k, _ := range m.Topics {
			dAtA[i] = 0xa
			i++
			v := m.Topics[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovSandglass(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovSandglass(uint64(len(k))) + msgSize
			i = encodeVarintSandglass(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintSandglass(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintSandglass(dAtA, i, uint64(v.Size()))
				n10, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n10
			}
		}
	}
	return i, nil
}

func (m *SyncResponse_SyncResponseTopic) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SyncResponse_SyncResponseTopic) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Partitions) > 0 {
		for k, _ := range m.Partitions {
			dAtA[i] = 0xa
			i++
			v := m.Partitions[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovSandglass(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovSandglass(uint64(len(k))) + msgSize
			i = encodeVarintSandglass(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintSandglass(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintSandglass(dAtA, i, uint64(v.Size()))
				n11, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n11
			}
		}
	}
	return i, nil
}

func encodeFixed64Sandglass(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Sandglass(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintSandglass(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Message) Size() (n int) {
	var l int
	_ = l
	l = len(m.Topic)
	if l > 0 {
		n += 1 + l + sovSandglass(uint64(l))
	}
	l = len(m.Partition)
	if l > 0 {
		n += 1 + l + sovSandglass(uint64(l))
	}
	l = m.Index.Size()
	n += 1 + l + sovSandglass(uint64(l))
	l = m.Offset.Size()
	n += 1 + l + sovSandglass(uint64(l))
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovSandglass(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovSandglass(uint64(l))
	}
	return n
}

func (m *DUIDReply) Size() (n int) {
	var l int
	_ = l
	l = m.Id.Size()
	n += 1 + l + sovSandglass(uint64(l))
	return n
}

func (m *CreateTopicParams) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovSandglass(uint64(l))
	}
	if m.Kind != 0 {
		n += 1 + sovSandglass(uint64(m.Kind))
	}
	if m.ReplicationFactor != 0 {
		n += 1 + sovSandglass(uint64(m.ReplicationFactor))
	}
	if m.NumPartitions != 0 {
		n += 1 + sovSandglass(uint64(m.NumPartitions))
	}
	if m.StorageDriver != 0 {
		n += 1 + sovSandglass(uint64(m.StorageDriver))
	}
	return n
}

func (m *TopicReply) Size() (n int) {
	var l int
	_ = l
	if m.Success {
		n += 2
	}
	return n
}

func (m *StoreLocallyReply) Size() (n int) {
	var l int
	_ = l
	if m.Success {
		n += 2
	}
	return n
}

func (m *FetchFromRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Topic)
	if l > 0 {
		n += 1 + l + sovSandglass(uint64(l))
	}
	l = len(m.Partition)
	if l > 0 {
		n += 1 + l + sovSandglass(uint64(l))
	}
	l = m.From.Size()
	n += 1 + l + sovSandglass(uint64(l))
	return n
}

func (m *FetchRangeRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Topic)
	if l > 0 {
		n += 1 + l + sovSandglass(uint64(l))
	}
	l = len(m.Partition)
	if l > 0 {
		n += 1 + l + sovSandglass(uint64(l))
	}
	l = m.From.Size()
	n += 1 + l + sovSandglass(uint64(l))
	l = m.To.Size()
	n += 1 + l + sovSandglass(uint64(l))
	return n
}

func (m *GetRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Topic)
	if l > 0 {
		n += 1 + l + sovSandglass(uint64(l))
	}
	l = len(m.Partition)
	if l > 0 {
		n += 1 + l + sovSandglass(uint64(l))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovSandglass(uint64(l))
	}
	return n
}

func (m *ConsumeFromGroupRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Topic)
	if l > 0 {
		n += 1 + l + sovSandglass(uint64(l))
	}
	l = len(m.Partition)
	if l > 0 {
		n += 1 + l + sovSandglass(uint64(l))
	}
	l = len(m.ConsumerGroupName)
	if l > 0 {
		n += 1 + l + sovSandglass(uint64(l))
	}
	l = len(m.ConsumerName)
	if l > 0 {
		n += 1 + l + sovSandglass(uint64(l))
	}
	return n
}

func (m *OffsetChangeRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Topic)
	if l > 0 {
		n += 1 + l + sovSandglass(uint64(l))
	}
	l = len(m.Partition)
	if l > 0 {
		n += 1 + l + sovSandglass(uint64(l))
	}
	l = len(m.ConsumerGroup)
	if l > 0 {
		n += 1 + l + sovSandglass(uint64(l))
	}
	l = len(m.ConsumerName)
	if l > 0 {
		n += 1 + l + sovSandglass(uint64(l))
	}
	l = m.Offset.Size()
	n += 1 + l + sovSandglass(uint64(l))
	return n
}

func (m *OffsetChangeReply) Size() (n int) {
	var l int
	_ = l
	if m.Success {
		n += 2
	}
	return n
}

func (m *LastOffsetReply) Size() (n int) {
	var l int
	_ = l
	l = m.Offset.Size()
	n += 1 + l + sovSandglass(uint64(l))
	return n
}

func (m *LastOffsetRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Topic)
	if l > 0 {
		n += 1 + l + sovSandglass(uint64(l))
	}
	l = len(m.Partition)
	if l > 0 {
		n += 1 + l + sovSandglass(uint64(l))
	}
	l = len(m.ConsumerGroup)
	if l > 0 {
		n += 1 + l + sovSandglass(uint64(l))
	}
	l = len(m.ConsumerName)
	if l > 0 {
		n += 1 + l + sovSandglass(uint64(l))
	}
	if m.Kind != 0 {
		n += 1 + sovSandglass(uint64(m.Kind))
	}
	return n
}

func (m *FetchFromSyncRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Topic)
	if l > 0 {
		n += 1 + l + sovSandglass(uint64(l))
	}
	l = len(m.Partition)
	if l > 0 {
		n += 1 + l + sovSandglass(uint64(l))
	}
	l = len(m.From)
	if l > 0 {
		n += 1 + l + sovSandglass(uint64(l))
	}
	return n
}

func (m *HasResponse) Size() (n int) {
	var l int
	_ = l
	if m.Exists {
		n += 2
	}
	return n
}

func (m *SyncRequest) Size() (n int) {
	var l int
	_ = l
	if len(m.Topics) > 0 {
		for k, v := range m.Topics {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovSandglass(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovSandglass(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovSandglass(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *SyncRequest_SyncRequestTopic) Size() (n int) {
	var l int
	_ = l
	if len(m.Partitions) > 0 {
		for _, s := range m.Partitions {
			l = len(s)
			n += 1 + l + sovSandglass(uint64(l))
		}
	}
	return n
}

func (m *SyncResponse) Size() (n int) {
	var l int
	_ = l
	if len(m.Topics) > 0 {
		for k, v := range m.Topics {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovSandglass(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovSandglass(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovSandglass(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *SyncResponse_SyncResponseTopic) Size() (n int) {
	var l int
	_ = l
	if len(m.Partitions) > 0 {
		for k, v := range m.Partitions {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovSandglass(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovSandglass(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovSandglass(uint64(mapEntrySize))
		}
	}
	return n
}

func sovSandglass(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozSandglass(x uint64) (n int) {
	return sovSandglass(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *Message) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Message{`,
		`Topic:` + fmt.Sprintf("%v", this.Topic) + `,`,
		`Partition:` + fmt.Sprintf("%v", this.Partition) + `,`,
		`Index:` + fmt.Sprintf("%v", this.Index) + `,`,
		`Offset:` + fmt.Sprintf("%v", this.Offset) + `,`,
		`Key:` + fmt.Sprintf("%v", this.Key) + `,`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DUIDReply) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DUIDReply{`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateTopicParams) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateTopicParams{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Kind:` + fmt.Sprintf("%v", this.Kind) + `,`,
		`ReplicationFactor:` + fmt.Sprintf("%v", this.ReplicationFactor) + `,`,
		`NumPartitions:` + fmt.Sprintf("%v", this.NumPartitions) + `,`,
		`StorageDriver:` + fmt.Sprintf("%v", this.StorageDriver) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TopicReply) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TopicReply{`,
		`Success:` + fmt.Sprintf("%v", this.Success) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StoreLocallyReply) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StoreLocallyReply{`,
		`Success:` + fmt.Sprintf("%v", this.Success) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FetchFromRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FetchFromRequest{`,
		`Topic:` + fmt.Sprintf("%v", this.Topic) + `,`,
		`Partition:` + fmt.Sprintf("%v", this.Partition) + `,`,
		`From:` + fmt.Sprintf("%v", this.From) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FetchRangeRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FetchRangeRequest{`,
		`Topic:` + fmt.Sprintf("%v", this.Topic) + `,`,
		`Partition:` + fmt.Sprintf("%v", this.Partition) + `,`,
		`From:` + fmt.Sprintf("%v", this.From) + `,`,
		`To:` + fmt.Sprintf("%v", this.To) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetRequest{`,
		`Topic:` + fmt.Sprintf("%v", this.Topic) + `,`,
		`Partition:` + fmt.Sprintf("%v", this.Partition) + `,`,
		`Key:` + fmt.Sprintf("%v", this.Key) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ConsumeFromGroupRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ConsumeFromGroupRequest{`,
		`Topic:` + fmt.Sprintf("%v", this.Topic) + `,`,
		`Partition:` + fmt.Sprintf("%v", this.Partition) + `,`,
		`ConsumerGroupName:` + fmt.Sprintf("%v", this.ConsumerGroupName) + `,`,
		`ConsumerName:` + fmt.Sprintf("%v", this.ConsumerName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *OffsetChangeRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&OffsetChangeRequest{`,
		`Topic:` + fmt.Sprintf("%v", this.Topic) + `,`,
		`Partition:` + fmt.Sprintf("%v", this.Partition) + `,`,
		`ConsumerGroup:` + fmt.Sprintf("%v", this.ConsumerGroup) + `,`,
		`ConsumerName:` + fmt.Sprintf("%v", this.ConsumerName) + `,`,
		`Offset:` + fmt.Sprintf("%v", this.Offset) + `,`,
		`}`,
	}, "")
	return s
}
func (this *OffsetChangeReply) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&OffsetChangeReply{`,
		`Success:` + fmt.Sprintf("%v", this.Success) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LastOffsetReply) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LastOffsetReply{`,
		`Offset:` + fmt.Sprintf("%v", this.Offset) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LastOffsetRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LastOffsetRequest{`,
		`Topic:` + fmt.Sprintf("%v", this.Topic) + `,`,
		`Partition:` + fmt.Sprintf("%v", this.Partition) + `,`,
		`ConsumerGroup:` + fmt.Sprintf("%v", this.ConsumerGroup) + `,`,
		`ConsumerName:` + fmt.Sprintf("%v", this.ConsumerName) + `,`,
		`Kind:` + fmt.Sprintf("%v", this.Kind) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FetchFromSyncRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FetchFromSyncRequest{`,
		`Topic:` + fmt.Sprintf("%v", this.Topic) + `,`,
		`Partition:` + fmt.Sprintf("%v", this.Partition) + `,`,
		`From:` + fmt.Sprintf("%v", this.From) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HasResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HasResponse{`,
		`Exists:` + fmt.Sprintf("%v", this.Exists) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SyncRequest) String() string {
	if this == nil {
		return "nil"
	}
	keysForTopics := make([]string, 0, len(this.Topics))
	for k, _ := range this.Topics {
		keysForTopics = append(keysForTopics, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForTopics)
	mapStringForTopics := "map[string]*SyncRequest_SyncRequestTopic{"
	for _, k := range keysForTopics {
		mapStringForTopics += fmt.Sprintf("%v: %v,", k, this.Topics[k])
	}
	mapStringForTopics += "}"
	s := strings.Join([]string{`&SyncRequest{`,
		`Topics:` + mapStringForTopics + `,`,
		`}`,
	}, "")
	return s
}
func (this *SyncRequest_SyncRequestTopic) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SyncRequest_SyncRequestTopic{`,
		`Partitions:` + fmt.Sprintf("%v", this.Partitions) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SyncResponse) String() string {
	if this == nil {
		return "nil"
	}
	keysForTopics := make([]string, 0, len(this.Topics))
	for k, _ := range this.Topics {
		keysForTopics = append(keysForTopics, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForTopics)
	mapStringForTopics := "map[string]*SyncResponse_SyncResponseTopic{"
	for _, k := range keysForTopics {
		mapStringForTopics += fmt.Sprintf("%v: %v,", k, this.Topics[k])
	}
	mapStringForTopics += "}"
	s := strings.Join([]string{`&SyncResponse{`,
		`Topics:` + mapStringForTopics + `,`,
		`}`,
	}, "")
	return s
}
func (this *SyncResponse_SyncResponseTopic) String() string {
	if this == nil {
		return "nil"
	}
	keysForPartitions := make([]string, 0, len(this.Partitions))
	for k, _ := range this.Partitions {
		keysForPartitions = append(keysForPartitions, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForPartitions)
	mapStringForPartitions := "map[string]*Message{"
	for _, k := range keysForPartitions {
		mapStringForPartitions += fmt.Sprintf("%v: %v,", k, this.Partitions[k])
	}
	mapStringForPartitions += "}"
	s := strings.Join([]string{`&SyncResponse_SyncResponseTopic{`,
		`Partitions:` + mapStringForPartitions + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringSandglass(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *Message) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSandglass
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Message: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Message: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Topic", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Topic = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Partition", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Partition = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Index.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Offset.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSandglass(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSandglass
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DUIDReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSandglass
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DUIDReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DUIDReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Id.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSandglass(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSandglass
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateTopicParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSandglass
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateTopicParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateTopicParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			m.Kind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Kind |= (TopicKind(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicationFactor", wireType)
			}
			m.ReplicationFactor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplicationFactor |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumPartitions", wireType)
			}
			m.NumPartitions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumPartitions |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageDriver", wireType)
			}
			m.StorageDriver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StorageDriver |= (StorageDriver(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSandglass(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSandglass
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TopicReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSandglass
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TopicReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TopicReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Success = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipSandglass(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSandglass
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StoreLocallyReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSandglass
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StoreLocallyReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StoreLocallyReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Success = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipSandglass(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSandglass
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FetchFromRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSandglass
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FetchFromRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FetchFromRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Topic", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Topic = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Partition", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Partition = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.From.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSandglass(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSandglass
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FetchRangeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSandglass
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FetchRangeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FetchRangeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Topic", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Topic = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Partition", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Partition = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.From.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.To.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSandglass(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSandglass
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSandglass
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Topic", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Topic = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Partition", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Partition = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSandglass(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSandglass
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConsumeFromGroupRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSandglass
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConsumeFromGroupRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConsumeFromGroupRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Topic", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Topic = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Partition", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Partition = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsumerGroupName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConsumerGroupName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsumerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConsumerName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSandglass(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSandglass
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OffsetChangeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSandglass
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OffsetChangeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OffsetChangeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Topic", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Topic = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Partition", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Partition = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsumerGroup", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConsumerGroup = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsumerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConsumerName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Offset.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSandglass(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSandglass
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OffsetChangeReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSandglass
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OffsetChangeReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OffsetChangeReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Success = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipSandglass(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSandglass
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LastOffsetReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSandglass
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LastOffsetReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LastOffsetReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Offset.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSandglass(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSandglass
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LastOffsetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSandglass
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LastOffsetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LastOffsetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Topic", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Topic = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Partition", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Partition = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsumerGroup", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConsumerGroup = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsumerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConsumerName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			m.Kind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Kind |= (LastOffsetRequest_Kind(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSandglass(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSandglass
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FetchFromSyncRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSandglass
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FetchFromSyncRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FetchFromSyncRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Topic", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Topic = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Partition", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Partition = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.From = append(m.From[:0], dAtA[iNdEx:postIndex]...)
			if m.From == nil {
				m.From = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSandglass(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSandglass
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HasResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSandglass
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HasResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HasResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exists", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Exists = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipSandglass(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSandglass
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SyncRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSandglass
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SyncRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SyncRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Topics", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthSandglass
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(dAtA[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.Topics == nil {
				m.Topics = make(map[string]*SyncRequest_SyncRequestTopic)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSandglass
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapmsglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSandglass
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					mapmsglen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if mapmsglen < 0 {
					return ErrInvalidLengthSandglass
				}
				postmsgIndex := iNdEx + mapmsglen
				if mapmsglen < 0 {
					return ErrInvalidLengthSandglass
				}
				if postmsgIndex > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := &SyncRequest_SyncRequestTopic{}
				if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
					return err
				}
				iNdEx = postmsgIndex
				m.Topics[mapkey] = mapvalue
			} else {
				var mapvalue *SyncRequest_SyncRequestTopic
				m.Topics[mapkey] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSandglass(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSandglass
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SyncRequest_SyncRequestTopic) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSandglass
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SyncRequestTopic: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SyncRequestTopic: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Partitions", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Partitions = append(m.Partitions, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSandglass(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSandglass
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SyncResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSandglass
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SyncResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SyncResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Topics", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthSandglass
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(dAtA[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.Topics == nil {
				m.Topics = make(map[string]*SyncResponse_SyncResponseTopic)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSandglass
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapmsglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSandglass
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					mapmsglen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if mapmsglen < 0 {
					return ErrInvalidLengthSandglass
				}
				postmsgIndex := iNdEx + mapmsglen
				if mapmsglen < 0 {
					return ErrInvalidLengthSandglass
				}
				if postmsgIndex > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := &SyncResponse_SyncResponseTopic{}
				if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
					return err
				}
				iNdEx = postmsgIndex
				m.Topics[mapkey] = mapvalue
			} else {
				var mapvalue *SyncResponse_SyncResponseTopic
				m.Topics[mapkey] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSandglass(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSandglass
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SyncResponse_SyncResponseTopic) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSandglass
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SyncResponseTopic: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SyncResponseTopic: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Partitions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthSandglass
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(dAtA[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.Partitions == nil {
				m.Partitions = make(map[string]*Message)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSandglass
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapmsglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSandglass
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					mapmsglen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if mapmsglen < 0 {
					return ErrInvalidLengthSandglass
				}
				postmsgIndex := iNdEx + mapmsglen
				if mapmsglen < 0 {
					return ErrInvalidLengthSandglass
				}
				if postmsgIndex > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := &Message{}
				if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
					return err
				}
				iNdEx = postmsgIndex
				m.Partitions[mapkey] = mapvalue
			} else {
				var mapvalue *Message
				m.Partitions[mapkey] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSandglass(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSandglass
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipSandglass(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowSandglass
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthSandglass
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowSandglass
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipSandglass(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthSandglass = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowSandglass   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("sandglass.proto", fileDescriptorSandglass) }

var fileDescriptorSandglass = []byte{
	// 1340 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x58, 0x4d, 0x6c, 0x1b, 0x45,
	0x14, 0xf6, 0xd8, 0x89, 0x5d, 0x3f, 0xc7, 0xcd, 0x7a, 0x1a, 0x8a, 0xe5, 0x06, 0xa7, 0x0c, 0x2d,
	0x98, 0xa8, 0x8d, 0x2b, 0x57, 0x08, 0x1a, 0x44, 0x48, 0x9c, 0xb4, 0x49, 0xd5, 0xf4, 0x6f, 0xd3,
	0x20, 0xd1, 0x03, 0x68, 0xb3, 0x3b, 0x71, 0x56, 0x5e, 0xef, 0x98, 0x9d, 0x71, 0xa8, 0x55, 0x55,
	0x42, 0x1c, 0xb8, 0x70, 0xe4, 0xc2, 0x8d, 0x2b, 0x77, 0xc4, 0x01, 0x6e, 0x88, 0x4b, 0x8f, 0x48,
	0x1c, 0x40, 0x1c, 0x2a, 0x1a, 0xe0, 0xc4, 0x99, 0x3b, 0xda, 0xd9, 0xb5, 0x3d, 0xeb, 0x9f, 0xa4,
	0x75, 0x0e, 0x70, 0xf2, 0xce, 0x9b, 0x37, 0xef, 0x7d, 0xef, 0xcd, 0x7b, 0x6f, 0x3e, 0x19, 0xa6,
	0xb9, 0xe1, 0x5a, 0x35, 0xc7, 0xe0, 0x7c, 0xa1, 0xe9, 0x31, 0xc1, 0x70, 0xba, 0x2b, 0x28, 0xcc,
	0xd6, 0x18, 0xab, 0x39, 0xb4, 0x6c, 0x34, 0xed, 0xb2, 0xe1, 0xba, 0x4c, 0x18, 0xc2, 0x66, 0x6e,
	0xa8, 0x58, 0xb8, 0x58, 0xb3, 0xc5, 0x5e, 0x6b, 0x67, 0xc1, 0x64, 0x8d, 0x72, 0x8d, 0xd5, 0x58,
	0x59, 0x8a, 0x77, 0x5a, 0xbb, 0x72, 0x25, 0x17, 0xf2, 0x2b, 0x50, 0x27, 0x7f, 0x23, 0x48, 0xdd,
	0xa4, 0x9c, 0x1b, 0x35, 0x8a, 0x67, 0x60, 0x52, 0xb0, 0xa6, 0x6d, 0xe6, 0xd1, 0x59, 0x54, 0x4a,
	0xeb, 0xc1, 0x02, 0xcf, 0x42, 0xba, 0x69, 0x78, 0xc2, 0xf6, 0x9d, 0xe4, 0xe3, 0x72, 0xa7, 0x27,
	0xc0, 0xcb, 0x30, 0x69, 0xbb, 0x16, 0x7d, 0x90, 0x4f, 0x9c, 0x45, 0xa5, 0xa9, 0xea, 0xfc, 0xe3,
	0x27, 0x73, 0xb1, 0xdf, 0x9e, 0xcc, 0x11, 0x05, 0x85, 0x49, 0x1d, 0x8f, 0xba, 0x7b, 0xd4, 0x16,
	0x65, 0x3f, 0x88, 0x5d, 0xc7, 0xa8, 0xd3, 0x85, 0xeb, 0x6b, 0x7a, 0x70, 0x10, 0x57, 0x21, 0xc9,
	0x76, 0x77, 0x39, 0x15, 0xf9, 0x89, 0xe7, 0x36, 0x11, 0x9e, 0xc4, 0x1a, 0x24, 0xea, 0xb4, 0x9d,
	0x9f, 0xf4, 0x0d, 0xe8, 0xfe, 0xa7, 0x1f, 0xcb, 0xbe, 0xe1, 0xb4, 0x68, 0x3e, 0x29, 0x65, 0xc1,
	0x82, 0xac, 0x43, 0x7a, 0x6d, 0xfb, 0xfa, 0x9a, 0x4e, 0x9b, 0x4e, 0x1b, 0x2f, 0x42, 0xdc, 0xb6,
	0x64, 0xac, 0xcf, 0xe7, 0x34, 0x6e, 0x5b, 0xe4, 0x2f, 0x04, 0xb9, 0x55, 0x8f, 0x1a, 0x82, 0xde,
	0xf3, 0x93, 0x74, 0xc7, 0xf0, 0x8c, 0x06, 0xc7, 0x18, 0x26, 0x5c, 0xa3, 0x41, 0xc3, 0xfc, 0xc9,
	0x6f, 0x5c, 0x82, 0x89, 0xba, 0xed, 0x5a, 0x32, 0x73, 0x27, 0x2b, 0x33, 0x0b, 0xbd, 0x8b, 0x95,
	0x27, 0x6f, 0xd8, 0xae, 0xa5, 0x4b, 0x0d, 0x7c, 0x01, 0x72, 0x1e, 0x6d, 0x3a, 0xb6, 0x29, 0xef,
	0xf3, 0x9a, 0x61, 0x0a, 0xe6, 0xc9, 0xb4, 0x4e, 0xea, 0x83, 0x1b, 0xf8, 0x1c, 0x64, 0xdd, 0x56,
	0xe3, 0x4e, 0xe7, 0x22, 0xb8, 0xcc, 0xde, 0xa4, 0x1e, 0x15, 0xe2, 0x25, 0xc8, 0x72, 0xc1, 0x3c,
	0xa3, 0x46, 0xd7, 0x3c, 0x7b, 0x9f, 0x7a, 0x32, 0x45, 0x27, 0x2b, 0x79, 0x05, 0xc6, 0x96, 0xba,
	0xaf, 0x47, 0xd5, 0xc9, 0xab, 0x00, 0x12, 0x66, 0x90, 0xb1, 0x3c, 0xa4, 0x78, 0xcb, 0x34, 0x29,
	0xe7, 0x32, 0xc4, 0x13, 0x7a, 0x67, 0x49, 0x2e, 0x42, 0xce, 0xb7, 0x43, 0x37, 0x99, 0x69, 0x38,
	0x4e, 0xfb, 0x28, 0xf5, 0xcf, 0x10, 0x68, 0xd7, 0xa8, 0x30, 0xf7, 0xae, 0x79, 0xac, 0xa1, 0xd3,
	0x8f, 0x5a, 0x94, 0x8b, 0xb1, 0xca, 0x6f, 0x09, 0x26, 0x76, 0x3d, 0xd6, 0x18, 0xa3, 0xfa, 0xe4,
	0x39, 0xf2, 0x23, 0x82, 0x9c, 0x04, 0xa2, 0x1b, 0x6e, 0x8d, 0xfe, 0x87, 0x48, 0xfc, 0x6a, 0x14,
	0x6c, 0x8c, 0x16, 0x88, 0x0b, 0x46, 0x74, 0x80, 0x75, 0x2a, 0x8e, 0x83, 0x3e, 0x6c, 0xa0, 0x44,
	0xb7, 0x81, 0xc8, 0x57, 0x08, 0x5e, 0x5c, 0x65, 0x2e, 0x6f, 0x35, 0xa8, 0x7f, 0x49, 0xeb, 0x1e,
	0x6b, 0x35, 0x8f, 0xe3, 0xe1, 0x02, 0xe4, 0xcc, 0xc0, 0x9c, 0x27, 0x6d, 0xdd, 0xf2, 0x1b, 0x25,
	0x21, 0xb5, 0x06, 0x37, 0x30, 0x81, 0xa9, 0x8e, 0x50, 0x2a, 0x4e, 0x48, 0xc5, 0x88, 0x8c, 0xfc,
	0x82, 0xe0, 0xd4, 0x6d, 0xd9, 0xff, 0xab, 0x7b, 0xc7, 0xbd, 0xbd, 0x73, 0x90, 0x8d, 0x80, 0x08,
	0x91, 0x45, 0x85, 0xcf, 0x82, 0x4a, 0x19, 0x67, 0x93, 0xe3, 0x8e, 0x33, 0xbf, 0x9b, 0xa2, 0x81,
	0x1d, 0xde, 0x4d, 0xdb, 0x30, 0xbd, 0x69, 0x70, 0x11, 0x1c, 0x09, 0x94, 0x7b, 0x28, 0xd0, 0xd8,
	0x28, 0x3e, 0x8f, 0x43, 0x4e, 0xb5, 0xfb, 0x7f, 0xc8, 0xee, 0x1b, 0xe1, 0x34, 0x0d, 0xc6, 0xd8,
	0xcb, 0xca, 0x18, 0x1b, 0x40, 0xba, 0xd0, 0x1b, 0xad, 0x64, 0x05, 0x26, 0xfc, 0x15, 0xce, 0x40,
	0x6a, 0xdb, 0xad, 0xbb, 0xec, 0x63, 0x57, 0x8b, 0xe1, 0x29, 0x38, 0x11, 0x16, 0xb8, 0xa5, 0x21,
	0xac, 0xc1, 0xd4, 0x8a, 0xe9, 0x6f, 0x39, 0xd4, 0xaa, 0x51, 0x4b, 0x8b, 0x07, 0xfb, 0x8d, 0x86,
	0x2d, 0xa8, 0xa5, 0x25, 0xc8, 0x07, 0x30, 0xd3, 0x9d, 0x58, 0x5b, 0x6d, 0xd7, 0x3c, 0x4e, 0x3e,
	0xb0, 0x3a, 0x2b, 0xc2, 0x49, 0x74, 0x1e, 0x32, 0x1b, 0x06, 0xd7, 0x29, 0x6f, 0x32, 0x97, 0x53,
	0x7c, 0x1a, 0x92, 0xf4, 0x81, 0xcd, 0x45, 0xe7, 0xb2, 0xc3, 0x15, 0x79, 0x8a, 0x20, 0xa3, 0xba,
	0x5f, 0x84, 0xa4, 0xf4, 0xe8, 0xeb, 0x25, 0x4a, 0x99, 0x0a, 0x51, 0x27, 0x7b, 0x4f, 0x2f, 0x78,
	0x6c, 0xf8, 0x55, 0x57, 0x78, 0x6d, 0x3d, 0x3c, 0x51, 0xa8, 0x80, 0xa6, 0xa8, 0x48, 0x0d, 0x5c,
	0x04, 0x68, 0xf6, 0xde, 0x14, 0xdf, 0x66, 0x5a, 0x57, 0x24, 0x85, 0x1d, 0xc8, 0x28, 0xa6, 0x3a,
	0x73, 0x23, 0x88, 0x5d, 0x3e, 0xbc, 0xef, 0x74, 0x1e, 0x5e, 0x3f, 0xea, 0x4c, 0xe5, 0xb5, 0x11,
	0x78, 0xfa, 0x1d, 0x87, 0x2f, 0xf4, 0x62, 0xfc, 0x2d, 0x44, 0xfe, 0x89, 0xc3, 0x54, 0xb0, 0x1f,
	0x26, 0xe3, 0xed, 0xbe, 0x20, 0x5f, 0x19, 0x30, 0x1a, 0x28, 0x0e, 0x8d, 0xf2, 0x07, 0x04, 0x39,
	0x55, 0x29, 0x88, 0xf3, 0xfd, 0x81, 0x38, 0x33, 0x95, 0x2b, 0xa3, 0xcc, 0x0e, 0x1c, 0x5f, 0xe8,
	0x3d, 0xb1, 0x81, 0x33, 0x35, 0x45, 0x77, 0x61, 0xba, 0x6f, 0x7b, 0x48, 0x9a, 0x4a, 0xd1, 0x34,
	0x61, 0xc5, 0x75, 0x48, 0xc7, 0x94, 0x8c, 0x14, 0xac, 0xa3, 0xb2, 0xfe, 0x6e, 0xd4, 0xdc, 0xeb,
	0xcf, 0x1c, 0x89, 0xe2, 0x65, 0xfe, 0x22, 0xa4, 0xbb, 0x9c, 0x04, 0x67, 0x21, 0x7d, 0xcf, 0x6e,
	0x50, 0xcf, 0x5f, 0x68, 0x31, 0x9c, 0x83, 0xec, 0x2a, 0x6b, 0x34, 0x0d, 0x53, 0x50, 0x4b, 0x8a,
	0xd0, 0x7c, 0x09, 0xb2, 0x11, 0xee, 0xe0, 0x77, 0x97, 0xce, 0xcc, 0x3a, 0x5f, 0xab, 0x6a, 0x31,
	0x0c, 0x90, 0xac, 0x1a, 0x56, 0x8d, 0x7a, 0x1a, 0x9a, 0xbf, 0x04, 0x9a, 0xdf, 0x69, 0x36, 0x17,
	0xd4, 0x35, 0xdb, 0x9b, 0x74, 0x9f, 0x3a, 0x38, 0x05, 0x89, 0xdb, 0xb7, 0xae, 0x06, 0x8a, 0x77,
	0xb7, 0x6f, 0xeb, 0xdb, 0x37, 0x35, 0xf0, 0x85, 0x2b, 0x9b, 0x9b, 0xda, 0x4c, 0xe5, 0x5b, 0x80,
	0x6c, 0xd5, 0x63, 0x75, 0xea, 0x6d, 0x51, 0x6f, 0xdf, 0x36, 0x29, 0x7e, 0x0f, 0x32, 0x0a, 0xe1,
	0xc2, 0xb3, 0x4a, 0x84, 0x03, 0x44, 0xac, 0xf0, 0x42, 0x3f, 0xcd, 0x92, 0x53, 0x91, 0xe0, 0x4f,
	0x7f, 0xfe, 0xf3, 0x8b, 0xf8, 0x14, 0x49, 0x95, 0x83, 0xda, 0x58, 0x44, 0xf3, 0xd8, 0x85, 0xd4,
	0x9d, 0xd6, 0x8e, 0x63, 0xf3, 0x3d, 0x3c, 0xe4, 0x12, 0x0a, 0x2a, 0x61, 0xeb, 0x52, 0x47, 0x72,
	0x45, 0x1a, 0xba, 0x4c, 0xa6, 0x43, 0x43, 0xe5, 0x87, 0xf2, 0xf7, 0xd1, 0x22, 0x9a, 0xbf, 0xff,
	0x12, 0x39, 0xd3, 0x27, 0x2d, 0x3f, 0xec, 0x56, 0xc7, 0x23, 0xac, 0xc3, 0x29, 0xc9, 0x94, 0x42,
	0x07, 0x21, 0x61, 0x1a, 0xea, 0x7b, 0xb6, 0x8f, 0xa5, 0x45, 0xd8, 0x15, 0x49, 0x4b, 0x0c, 0x09,
	0x3f, 0x86, 0x65, 0x48, 0x77, 0x67, 0x13, 0x3e, 0xa3, 0x9c, 0xea, 0xe7, 0x58, 0x85, 0x21, 0x6e,
	0x48, 0xec, 0x12, 0xc2, 0x55, 0x80, 0x1e, 0x0d, 0x8a, 0x24, 0x77, 0x80, 0x1d, 0x8d, 0xb4, 0xf1,
	0x26, 0x9c, 0x58, 0xa7, 0xa2, 0xda, 0xbe, 0x41, 0xdb, 0x58, 0xbd, 0x80, 0x1e, 0x35, 0x19, 0x7e,
	0x14, 0x5f, 0x81, 0xe4, 0x86, 0xc1, 0x0f, 0x39, 0x76, 0x5a, 0x11, 0x2b, 0x43, 0x92, 0xc4, 0xf0,
	0x8d, 0x68, 0x36, 0xf9, 0x96, 0xf0, 0xa8, 0xd1, 0x18, 0x23, 0x9b, 0xb1, 0x12, 0xc2, 0xdf, 0xa0,
	0xa0, 0x4e, 0x55, 0xca, 0x83, 0xd5, 0x81, 0x3a, 0x82, 0x0f, 0x0d, 0x0d, 0x8b, 0xca, 0xeb, 0xf9,
	0x10, 0x1f, 0x56, 0x0c, 0xf7, 0x97, 0xf1, 0xd2, 0x21, 0xdb, 0xe5, 0x87, 0x03, 0xc4, 0x48, 0x91,
	0xc9, 0xe5, 0x25, 0x84, 0xbf, 0x43, 0x90, 0x51, 0x5e, 0x2e, 0x5c, 0x54, 0xc0, 0x0c, 0xa1, 0x47,
	0x91, 0x3c, 0x0c, 0xb0, 0x0c, 0xe2, 0x48, 0xd8, 0xbb, 0x64, 0xae, 0x83, 0xcb, 0x30, 0xeb, 0xc3,
	0xb0, 0xf9, 0x95, 0xbe, 0x4c, 0x96, 0x8e, 0xd0, 0xea, 0x8b, 0xa0, 0x1f, 0x3d, 0xfe, 0x1e, 0x41,
	0x32, 0x78, 0x63, 0x8f, 0x09, 0xdb, 0x93, 0xb0, 0x1d, 0x42, 0x3a, 0x80, 0x4c, 0x69, 0x75, 0x14,
	0xf2, 0x55, 0xb2, 0x72, 0xb4, 0xe2, 0x51, 0xe0, 0x37, 0x00, 0x7a, 0xa4, 0x23, 0xd2, 0x33, 0x03,
	0x5c, 0xa4, 0x50, 0x18, 0xb1, 0x2b, 0x4b, 0x0f, 0x6f, 0x40, 0x36, 0xc2, 0x2d, 0xf0, 0xdc, 0xb0,
	0x1e, 0x56, 0x9e, 0xcc, 0x51, 0x3d, 0x58, 0x3d, 0xff, 0xeb, 0xd3, 0x62, 0xec, 0x93, 0x83, 0x22,
	0xfa, 0xfa, 0xa0, 0x88, 0x1e, 0x1f, 0x14, 0xd1, 0x4f, 0x07, 0x45, 0xf4, 0xfb, 0x41, 0x11, 0x7d,
	0xf9, 0x47, 0x31, 0x76, 0x3f, 0xc5, 0x6b, 0xc1, 0xbf, 0x01, 0x49, 0xf9, 0x73, 0xf9, 0xdf, 0x00,
	0x00, 0x00, 0xff, 0xff, 0xe5, 0x70, 0x36, 0x4e, 0x67, 0x10, 0x00, 0x00,
}
